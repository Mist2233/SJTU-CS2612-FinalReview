## 从语法树到汇编代码
前面两节，构成了编译器的前端：
- [[PLC-2-Lexer]] 为词法分析，负责将源代码字符串切分为标记（token）。
- [[PLC-3-Parser]] 为语法分析，负责在词法分析的基础上，生成“解析树”或“抽象语法树”。

而本节则开启“编译器后端”的内容，即：
> 将前面生成的程序语法树转化为汇编代码。

为了将程序的语法树转化为汇编代码，我们需要如下环节（以处理 while + db 语言为例）：
- 拆分复合表达式：
	- 由于汇编程序不能处理复合表达式，因此需要将复合表达式拆分为一系列单步计算。
	- 在拆分过程中，需要引入额外的辅助变量。
- 生成基本块：
	- 汇编程序的结构不是树形结构，而是一个汇编指令的列表，其中包含少量的跳转语句。
	- 因此，需要将抽象语法树中的树形结构，转化为这样以列表为主的结构。
	- 后面，我们会详细讲解“基本块”和“控制流图”这两个概念。
- 分配寄存器：
	- 汇编程序中没有变量，只有寄存器和内存，因此需要用寄存器或者内存来存储程序变量（包括前面生成的辅助变量）。
	- 处于运行效率的考虑，应当尽可能使用寄存器，尽可能不使用内存（主存）。
- 生成汇编代码：
	- 最后，生成汇编代码时，可能还需要补充一些细节，例如基本块的排布等等。

## 拆分复合表达式
复合表达式，就是需要进行多步运算的表达式，但是众所周知，汇编里面，一条指令只能做一件事，因此我们需要拆分复合表达式。

具体来说，有如下原则：
### 关键点 1：每个赋值语句至多进行一步计算。
引入额外的辅助变量，来储存中间计算结果，确保操作的原子化。下面是一个简单的例子：

拆分前：
```
x + y + z < 10
```

拆分后：
```
#0 = x + y;
#1 = #0 + z
#1 < 10
```

### 关键点 2：转化后的程序仅在必要处保留树结构。
换言之：顺序执行的语句可以用链表存储。之所以在语法分析时使用树结构而此处不再使用树结构主要有两点原因：
- 没有必要，后续生成基本块时，每个基本块内的程序语句都是线性排列的；
- 线性表的操作更方便编程。

### 关键点 3：要妥善处理 while 循环条件的计算语句
在 AST 中，while 循环条件是一个表达式。但是，经过拆分后，这个表达式的计算将会变为一段程序语句以及一个表达式。

拆分后的 while 逻辑必须包含下面的部分：
- 标签：LABEL_1，循环的入口
- 条件计算：执行原本条件表达式对应的拆分后的指令
- 条件判定：检查条件是否仍然满足。如果条件不满足，则跳转到循环体外的 LABEL_2
- 循环体：执行原本的循环逻辑
- 回跳：跳转回 LABEL_1，重新计算条件

拆分前：
```
while (old_condition) do {
	...
	(old loop body)
	...	
}
```

拆分后：
```
LABEL_1:
	...
	(some computations)
	...
	if (! new_condition) then jmp LABEL_2
	...
	(new loop body)
	...
	jmp LABEL_1
LABEL_2:
	...	
```


### 关键点 4：要妥善处理短路求值。
由于短路求值的存在，and 和 or 必须转化为 if 语句。

**注意：针对 and 和 or 的拆分方式不一致！**

#### And 的拆分方式
拆分前：
```
if (p && *p != 0)
then {...}
else {...}
```

拆分后：
```
if(p)
then {
	#2 = *p;
	#1 = (#2 != 0);
}
else {
	#1 = 0;
}

if (#1)
then {...}
else {...}
```

#### Or 的拆分方式
拆分前：
```
if (p || *p != 0)
then {...}
else {...}
```

拆分后：
```
if (p)
then {
	#1 = 1;
}
else {
	#2 = *p;
	#1 = (#2 != 0);
}

if (#1)
then {...}
else {...}
```


### 再举一个例子
例子：
```
原始表达式: (a + b) * (c - d) + e
```

拆分结果：
```
#0 = a + b        ← 赋值语句1：简化左半部分
#1 = c - d        ← 赋值语句2：简化右半部分  
#2 = #0 * #1      ← 赋值语句3：简化乘法部分

#2 + e            ← 最终表达式：得到最终结果
```

## 生成基本块
在之前《计算机组成》这一课程中，也有提到基本块的概念。在本课程老师所给出的讲义中，虽然有“生成基本块”这一节，但是没有相应内容，在这里我做一个简单的补充。

什么是基本块？基本块被描述为一种“线性排列的程序语句列表”。或者说，它就是编译器后端将树形结构转化为列表结构的产物。

基本块有两大特征：
- 线性执行：在一个基本块内部，指令是线性执行的，不涉及复杂的树形图层。
- 无跳转性：基本块内部没有跳转指令。

什么是控制流图（Control Flow Graph, CFG）？控制流图就是将各个基本块连接起来的有向图。
- 在控制流图中，节点就是基本块，而边则代表了程序可能的执行路径。

> [!NOTE] 基本块和控制流图
> 简单来说，基本块就是一条直路，我们一路直行到底，然后进入下一个基本块，或者结束操作。在同一个基本块内部，不会涉及什么条件判断、来回跳转之类的操作；而控制流图就是由基本块作为节点的流程图。
> 
> 正因为基本块内部不涉及跳转之类的操作，所以它可以作为控制流图的顶点，而控制流图的边可以作为基本块之间的转换，这也是某种意义上的解耦。

拆分基本块的方法，就是从原本代码表示的树结构，生成一个控制流图。

通常来说，基本块的开头会标注当前基本块的号码，而基本块的结尾则是跳转到其他基本块的指令。

条件判断通常是基本块的最后一条语句，基本块结束之后，就会跳转到其他基本块，或者结束程序。

下面是一个基本块的拆分的例子：来自 [[Assignment1010]]
```
Block 0:
  #2 = read_int()     // 语句1
  #4 = 0              // 语句2
  jmp 1               // 语句3

Block 1:
  if (NE(#2, 0)) then jmp 2 else jmp 3  // 语句4

Block 2:
  #7 = DEREF(#2)      // 语句5
  #4 = PLUS(#4, #7)   // 语句6
  #8 = PLUS(#2, 8)    // 语句7
  #2 = DEREF(#8)      // 语句8
  jmp 1               // 语句9
```


关键点：
- **节点**：基本块（包含条件判断）
- **边**：跳转关系（不是基本块，是连接）
- **条件判断**：基本块的结尾，决定跳转方向

> [!NOTE]
> **控制流图的节点是基本块，边表示控制流的转移关系**。条件判断是基本块的组成部分，而不是独立的元素！


## 寄存器分配
我们前面提到过，将变量存储在寄存器中，读写效率是最高的。所以，我们要在寄存器有限的情况下，尽可能多地复用它们，或者说，让一个寄存器服务尽可能多的变量，并且不产生冲突。

什么时候可以复用寄存器？答案是，在不产生冲突的时候。更具体地说，对两个程序变量 x 和 y，如果它们的活跃时间完全不重合，那么可以给它们分配同一个寄存器。

怎么判断程序变量使用时间是否冲突？利用活性分析，确定每个变量活跃的时间，然后分析它们的时间重叠情况，最终得到干扰图。

### 活性分析
所谓活性分析，就是看程序变量的生命周期，主要是看下面两点：
- 变量在当前位置是否有值？
- 这个值后面什么时候需要复用？

一个变量是**活的（live）** 意思是：
- 它在当前位置有一个值（现在有）
- 这个值在将来某个地方还会被使用（未来还有）

重新定义会杀死变量的旧值。

明白了“活性”的内涵之后，就能进一步定义四类基本集合，以及对应的集合计算方法。
- **基本概念**：
	- $\text{in}(u)$：进入基本块 $u$ 时必须保证"活着"的变量集合
	- $\text{out}(u)$：离开基本块 $u$ 时必须保证"活着"的变量集合
	- $\text{def}(u)$：在基本块 $u$ 中被赋值（定义）的变量集合
	- $\text{use}(u)$：在基本块 $u$ 中被使用，且在使用前**未在本块中定义**的变量集合（也就是外部传入且被使用的变量集合）
- **计算方法**：
    $$\text{in}(u) = (\text{out}(u) \setminus \text{def}(u)) \cup \text{use}(u)$$
    $$\text{out}(u) = \bigcup_{v \in \text{succ}(u)} \text{in}(v)$$

第一个公式的理解（计算 `in` 集合）
- 对于一个基本块 `u`，它的 `in` 集合由两部分组成。
	- 第一部分：`use(u)`。这一部分很容易理解。如果一个变量在 `u` 中被用到，且不是在 `u` 中定义的，那么它一定是从之前的基本块中继承过来的，也就是说，这个变量在进入 `u` 的时候就活着。所以，它一定是 `in(u)` 的组成元素。
	- 第二部分：`out(u)\def(u)`。这一部分也很容易理解。如果一个变量在离开 `u` 时仍然活着，并且不是在 `u` 中被定义的，那么它也一定是从之前的基本块中继承过来的，也就是 `in(u)` 的组成元素。

第二个公式的理解（计算 `out` 集合）
- 对于一个基本块 `u`，它的 `out` 集合由 `u` 的所有后继基本块的 `in` 集合并集而成。
- 什么是后继基本块？如果一个基本块 `v` 能由 `u` 中的某个分支跳转得到，那么 `v` 就是 `u` 的后继基本块。`u` 的所有后继基本块组成的集合用 `succ(u)` 表示。
- 那么，这个公式也很好理解。每个后继基本块 `v`，它的 `in(v)` 都需要 `out(u)` 提供一部分元素。所以，逆推可得， `out(u)` 就是由全部的 `in(v)` 并集而成。


说了这么多，我们得回到主线：基于上面的四类集合和两个公式，活性分析到底要如何进行？

活性分析的过程，其实就是不断充实每个基本块的四个集合的过程，而这个过程是迭代的：
- 首先，对于一个给定的基本块 `u`，`def(u)` 和 `use(u)` 是确定的、不会随着迭代过程而变化的。所以，我们可以先确定所有基本块的这两个集合。
- 之后，将所有基本块的 `out` 集合的初始值都设定为空集，按照逻辑顺序，从后往前开始迭代
	- 通常是从程序结束的那个出口开始迭代。
	- 但是，对于 if-else 这样的分支语句，前后顺序判断也不太重要，任选一个开始迭代即可。
- 迭代多轮，直到所有基本块的四个集合的内容不再随着迭代而变化，就可以结束了。

有时候，在基本块的活性分析结束之后，还需要分析每一行代码的活性。这时候，就需要基于上面的得到的每个基本块的四个集合，在每一个基本块内逆向分析即可。
- 这是容易的，因为对于单独的一行代码，其 `def` `use` 集合都容易确定，而本行的 `in` 集合就是上一行的 `out` 集合，本行的 `out` 集合就是下一行的 `in` 集合。

### 简单寄存器分配算法
本课程只考虑最简单的寄存器分配，即每个变量对应一个寄存器，多个变量可能对应相同的寄存器。

实际上，寄存器分配的方式，就是图着色的方式：
- 这里的图，是寄存器之间的冲突图/干扰图 (Interference Graph)
- 颜色数量：表示可以分配的寄存器的数量。
- 相邻点同色：表示产生冲突，两个同时间“活着”的变量，分配了相同的寄存器。

我们的目标就是：在得到的干扰图中，用尽可能少的颜色，对所有点着色，并且保证所有相邻点不同色。

具体分配算法如下：
- 假设共有 K 个寄存器；这里我们考虑变量个数大于 K 的情况。（因为，如果变量个数不超过 K，那么可以直接一个变量分配一个寄存器，寄存器管够。）
- **步骤一，Simplify**：在 interference graph 中删除度数 < K（即度数不超过 K-1） 的节点，删除的节点用栈记录；
	- 为什么可以删除这些节点？注意到，节点其实就代表着变量，两个节点之间相连一条边，表示这两个节点的活性区间存在重叠部分，不能共用一个寄存器。简单来说，就是两个变量之间存在冲突。
	- 而节点的度数小于 K，就说明这些节点代表的变量至多与 K-1 个其他变量存在冲突，那么至少存在一个变量可以与该变量共用寄存器。
	- 所以，我们可以先删掉这些度数较小的点，后面再来处理它们。
- **步骤二，Spill**：如果无法 Simplify，就任意删除一个节点，再回到前面步骤一；
	- 同样的问题：为什么可以随机删除一个节点？不怕这个节点代表的变量分不到寄存器吗？不会出现这种情况，因为有“乐观染色”和“兜底机制”。
	- 何时触发 Spill？答案是，当 interference graph 中的所有节点度数都不小于 K 时。这个时候，算法无法执行 simplify 操作，进入死胡同。所以，执行 spill 操作是为了打破这个僵局。
	- 这个被删除的节点，如果运气足够好的话，后续还是能分配到一个寄存器的，它的邻居们不一定会把全部寄存器都占满。这就是“乐观染色”。
	- 而如果它的运气很差，所有寄存器都被占满了，我们还有 Start Over 机制，强行改写原本的代码逻辑，缩减活性区间，重新开始整个流程。
- **步骤三，Select**：按照删除节点的倒序（用栈存储节点，保证倒序分配）为所有变量分配寄存器；
	- 注：Simplify 删除的节点能够保证被分配到与 interference graph 上相邻节点不冲突的寄存器，Spill 变量可能可以分配到寄存器（假 Spill），也可能无法分配到寄存器（真 Spill），此时应当存储在内存中；
- **步骤四，Start over**：如果有至少一个节点无法分配到寄存器，则改写相关代码并重做 liveness 分析与上述所有步骤。

那么，这个 Start over 步骤该如何进行呢？也就是分割某些变量的活性区间，让它在某些情况下“死去”：
- 如果 3 号变量无法分配寄存器，并且存储在 `%rbp - 16` 地址，那么：
    ```
    #2 = #3 + 1
    ```
    ```
    #3 = #4
    ```
    - 分别会被改写为：
    ```
    #3 = * (%rbp - 16)
    #2 = #3 + 1
    ```
    ```
    #3 = *#4
    * (%rbp - 16) = #3
    ```
    - 这样，两次使用 `#3` 变量之间的代码 `#3` 都不再是 live 的了。
- 如果所有变量都分配到了寄存器，那么寄存器分配过程结束；如果有至少一个节点无法分配到寄存器，那么在执行完上述程序改写后，变量的 live 区域会大大缩小，此时应当重新进行 liveness 分析，并回到步骤一，从头开始重新分配寄存器，这个过程称为 Start over。往往经过至多 2-3 次 Start over 之后，寄存器分配算法就能顺利结束。

> [!NOTE]
> 越晚被删除的变量，表示越难给它分配寄存器，类似“刺头”，需要优先处理。
> 
> 而越早被删除的变量，其寄存器情况是一定能被保证的，因此可以晚点给它分配寄存器。
> 
> 如果有些变量确实分不到寄存器，那么就只能“委屈”它，让它被存到内存中去。

直观理解：
- 越晚删除 = 度数越高 = 冲突越多 = 越难分配 = 优先处理
- 越早删除 = 度数越低 = 冲突越少 = 容易分配 = 后续处理

## 举一个 Start Over 中改写代码的例子
为了直观地理解这个过程，我们构造一段包含“长寿命变量”的代码，并对比**溢出（Spill）改写**前后，该变量活性区间的变化。

### 1. 原始代码（改写前）

假设我们有三个寄存器 $K=3$，但程序中有多个变量。变量 `#3` 在第一行被定义，在第五行才被使用。

```
1:  #3 = 10                // 定义 #3，活性开始
2:  #1 = #4 + 1            // 与 #3 无关的操作
3:  #5 = #6 * 2            // 与 #3 无关的操作
4:  write_int(#1)          // 与 #3 无关的操作
5:  #2 = #3 + 1            // 最后一次使用 #3，活性结束
```

- **活性分析结果**：在第 2、3、4 行，变量 `#3` 都是 **Live** 的。
- **后果**：因为 `#3` 在 2-4 行一直占着位子，它会与这段区间内所有出现的变量（`#1, #4, #5, #6`）产生**冲突（Interference）**，在干扰图中连边。如果此时寄存器不够用，`#3` 这种“占着茅坑不拉屎”的变量就可能被选为 **Spill** 对象。

---

### 2. 改写后的代码（Start Over 准备）

假设我们将 `#3` 溢出到内存地址 `%rbp - 16`。根据来源 的原则，我们对代码进行如下“手术”：

```
1:  #3 = 10
2:  * (%rbp - 16) = #3     // [新增] 定义后立即写回内存，#3 的活性在此暂时结束

3:  #1 = #4 + 1            // 这里 #3 已经“死”了，寄存器可以给别人用
4:  #5 = #6 * 2            // 这里 #3 依然是“死”的
5:  write_int(#1)          // 这里 #3 依然是“死”的

6:  #3 = * (%rbp - 16)     // [新增] 使用前临时从内存加载，#3 的活性在此重新开启
7:  #2 = #3 + 1            // 使用完 #3，活性结束
```

---

### 3. 活性区间是如何被“削减”的？

让我们对比改写前后的活性状态（Live Set）：

|行号|改写前 `#3` 是否活着？|改写后 `#3` 是否活着？|解释|
|:--|:--|:--|:--|
|**1**|**Yes**|**Yes**|正在定义|
|**2**|**Yes**|**Yes -> No**|**关键点**：改写后，写回内存后 `#3` 就不再被需要了|
|**3**|**Yes**|**No**|此时寄存器里可以放变量 `#7` 或其他东西|
|**4**|**Yes**|**No**|`#3` 依然在内存里“睡觉”|
|**5**|**Yes**|**No**|`#3` 依然在内存里“睡觉”|
|**6**|**Yes**|**No -> Yes**|**关键点**：仅在计算加法前这一瞬间活了一下|
|**7**|**Yes**|**Yes -> No**|计算完毕，彻底死去|

**结论：**

- **改写前**：`#3` 的活性区间是 ****，跨越了 5 行代码。
- **改写后**：`#3` 的活性区间被切碎成了两个极小的片段：**** 和 ****。

---

### 4. 为什么这样就能分配成功了？

当你执行 **Start over**（步骤四）重新回到步骤一进行活性分析时：

1. **冲突消失**：在第 3、4、5 行，变量 `#3` 不再属于 `in(u)` 集合。
2. **度数降低**：变量 `#1, #4, #5, #6` 在干扰图中原本要与 `#3` 连边，现在发现 `#3` 不见了。它们的**度数（Degree）会下降**。
3. **Simplify 成功**：由于这些“邻居”的度数变小了，它们现在满足了“度数 $< K$”的条件，可以被成功压入栈中进行 **Simplify**。

**一句话总结：** 原本 `#3` 像是一块横在路中间的长木板（长寿命），挡住了所有车；改写后，它变成了两块碎木屑（短寿命），只在进场和出场时闪现一下，路中间（第 3-5 行）就腾出了巨大的空间供其他变量通行。