## 简介
本节介绍表达式的指称语义。

在学习完词法分析（将源代码字符串切分为 Token）、语法分析（根据 Token 生成 AST）以及编译器后端（将 AST 转化为汇编代码）之后，我们已经掌握了程序的“外形”，以及“如何在机器上实现它”。

指称语义 (Denatational Semantics) 则更进一步。它不关心程序在底层如何跳转，也不关心它由哪些字符组成。它关注的是：
> 这段程序的数学本质（或者说，程序的“含义”）是什么？

可以说，指称语义起到了承上启下的作用：
- 对编译器前端，指称语义是直接定义在 AST 上的递归函数。语法分析负责生成 AST，而指称语义则通过 `Fixpoint eval_com` 这样的函数，为树上的每个节点赋予数学意义。
- 对编译器后端，后端通过拆分表达式和生成基本块来“改变”程序结构。指称语义定义了变换前后的基准行为，确保编译器优化不会改变程序的原始语义。

简单来说，指称语义告诉我们“什么样的程序是行为一致的”，它提供了程序等价性和程序验证的理论基础。

## 程序的状态
在理解指称语义之前，我们先要理解程序的状态。

什么是程序的状态？在极简的 SimpleWhile 语言中，整数类型表达式中只有整数常量、变量、加法、减法与乘法运算：
```
EI ::= N | V | EI + EI | EI - EI | EI * EI
```

我们约定其中整数变量的值、整数运算的结果都是没有范围限制的（不出现溢出的问题）。基于这一约定，我们可以将状态定义为一个函数，它将程序中出现的每一个变量名映射到一个整数值：
$$
\text{state: var\_name} \to \mathbb{Z} 
$$

为什么可以这样定义？因为一个程序在某个运行时刻的状态，本质上就是看其中的变量在那个时刻各自的值。所以说，状态（state）其实就是各个变量名到自己所存储的值的映射。在 SimpleWhile 语言中，这个值是整数，所以我们用变量名到整数的映射来表示程序的状态。

一言以蔽之：
> 状态就是所有变量以及其对应取值的“快照”。

## SimpleWhile 中整数类型表达式的指称语义
进一步，整数类型表达式 $e$ 的行为（或者说，它的指称语义）可以被定义为 $e$ 在每个程序状态上的值。
- $[\![ e ]\!]: \text{state} \to \mathbb{Z}$，是一个程序状态到整数的映射。
- $[\![ e ]\!](s)$ 表示表达式 $e$ 在程序状态 $s$ 上的求值结果。

这个定义的含义是：
> 表达式 `e` 的“意义”不是一个单一的数字，而是一个“求值器”。这个求值器（函数 $[\![ e ]\!]$）接收一个程序状态 `s` 作为输入，然后输出表达式 `e` 在该状态下的具体整数值。我们用 $[\![ e ]\!](s)$ 来表示将这个求值器应用于特定状态 `s` 后得到的结果。

也就是说，（大多数的）表达式本身没有确定的值，而是变量的运算组合。只有当其中所有变量的值都被确定（也就是程序状态被确定），表达式才能写出一个确切的值。

将状态翻译为具体的值，这就是表达式的行为，或者说表达式的指称语义。

直观理解：考虑一个表达式，比如 `x + 5`。它的值是多少？

答案是：**不确定**。它的值*取决于*变量 `x` 的当前值。
*   如果当前状态是 `x=10`，那么表达式的值是 15。
*   如果当前状态是 `x=-2`，那么表达式的值是 3。。

> [!NOTE] 指称语义定义的合理性
> 指称语义定义的合理性在于，它捕捉到了表达式求值的“**动态性**”或者“**依赖性**”。
> 
> 一个表达式本身并没有一个固定的值，它更像是一个**计算规则**或者一个 **“配方”**。你必须给我当前的“原料”（即程序状态），我才能根据这个配方给你做出“成品”（即最终的整数值）。
> 
> 它精确地将表达式的“意义”从一个不确定的、依赖上下文的值，提升为了一个确定的、独立的数学对象——一个从上下文（state）到结果（integer）的函数。

## 有符号 64 位运算的表达式语义
简单看了一下，就是把越界的情况的值都设置为 $\epsilon$。 

略，后续有时间再补充。
## 行为等价
### 定义
经过前面的分析，我们明白了，指称语义就是一个翻译器，它的行为就是将一个程序状态翻译为对应的整数值。

如果两个表达式，它们的指称语义总是做出相同的翻译行为，那么这两个表达式在某种意义上是等价的，这种等价被称为“**行为等价**”。

> [!NOTE] 行为等价的定义
> 已知表达式 $e_{1}$ 和表达式 $e_{2}$，若
> $$
> [\![ e_{1} ]\!](s) = [\![ e_{2} ]\!](s), ~ \forall s \in \text{state}
> $$
> 则称这两个表达式行为等价。


### 代数性质
整数类型表达式的行为等价符合几条重要的代数性质。

首先，由其定义不难推出，行为等价满足：
- 自反性：自己和自己行为等价。
- 对称性：a 和 b 行为等价，等同于 b 和 a 行为等价。
- 传递性：a 和 b 行为等价，b 和 c 行为等价，则 a 和 c 行为等价。

因此，行为等价是等价关系的一种。

其次，行为等价满足同余性质，其含义为：
- 如果子表达式之间等价，那么由它们构成的更大的表达式之间也是等价的。
- 这保证了我们可以对程序进行局部替换和优化。

