## 解析树和抽象语法树
课程核心：如何从前端的源代码，经过词法分析得到 token 流，再经过语法分析构建抽象语法树，并以此作为后续语义分析和代码生成的基准。

什么是程序的语法？什么样的程序，它们的程序语句是相同的？看下面这两个例子：
```
y = (x) + 1
y = x + 1
```

上面两段代码，词法分析之后，会得到不同的结果，但是最终得到的抽象语法树是相同的。
- 现在的词法分析器，比如 Flex，通常会忽略空格以及注释，但不会忽略括号。

语法树/解析树(Parsing Tree)：
- 语法树是编译器对你写的代码的语法结构进行分析之后（实际上在词法分析之后），形成的一种树状数据结构。
- 即将源代码中出现的所有语法结构，用树结构的方式表示出来。

语法结构中，一些内容其实没有实际上的语法含义（比如，运算中的括号、程序执行时的分号），但对程序执行起到一些其他作用，这样的多余结构，如果将其从解析树中去掉，就可以得到抽象语法树。

我们用抽象语法树表示一个程序的语法结构。如果两个程序的抽象语法树相同，我们就说它们是语法上相同的程序。

语法树，一般说的就是语法解析树，也可能是抽象语法树。

> [!NOTE] 解析树和抽象语法树有什么区别？
> - 解析树（ParsingTree）：忠实地描述了程序语句的所有语法结构，包括括号、分号等等表示运算先后顺序的内容。
> - 抽象语法树（AbstractSyntaxTree）：在语法树的基础上，去掉了表示运算先后顺序的内容。
> 	- 为什么可以去掉？因为树这个结构，本身就蕴含了运算顺序，所以不需要多余的内容再来表示运算顺序。


词法分析和语法分析：
- 词法分析和语法分析是编译器前端的两个核心阶段。
- 词法分析：
	- 任务：编译器的第一步，将源代码的字符串切分为一个个具有独立意义的 token。
	- 方法：基于正则表达式，通过构造有限状态自动机 (NFA/DFA) 来实现。
- 语法分析：
	- 任务：在词法分析的基础上，进一步分析这些 token 之间的结构关系，生成解析树 (Parsing Tree) 和抽象语法树 (AST)
	- 方法：基于上下文无关语法 (CFG)，通过“移入-规约”等算法来处理更复杂的结构。
	- 语法分析中的终结符集合，通常就是词法分析定义的 token 集合。

## While 语言
这里定义了 While 语言的基本语法结构。

一开始可能看不懂：这些玩意都是啥？不急，我们慢慢来看。

### BNF 范式
BNF 是一种用于描述上下文无关语法的符号，主要是下面两个符号：
- `::=` 表示“定义为”，即给某个东西下定义时，就用 `::=` 这个符号。
- `|` 表示“或者”，即某个东西有多种可能的表现形式，只要符合一种即可时，就用 `|` 这个符号。

明白了这一点，我们看后面的 while 语言定义，就非常简单明了。

### While 语言定义（基础版本）
- 常数 N：while 语言的常数是以非 0 数字开头的一串数字或者 0
- 保留字：`if, then, else, while, do`
- 变量名 V：第一个字符是字母或者下划线，可以包含字母、数字、下划线；保留字不是变量名。
- 表达式 E：常数、变量、四则算术运算、取相反数、模运算、各种大小比较、与、或、非。
- 语句 C：赋值语句、连续执行语句、分支语句、循环语句。

### While 语言 + Dereference (解引用) + Built-in functions (内置函数)
这是在 while 语言的基础上，增加了解引用操作，以及一些内置函数。

具体来说，定义变成了下面这个样子：
- 表达式 E 的定义中，增加了 `*E` `malloc(E)` `read_int()` `read_char` 这四个操作。
- 语句 C 的定义中，增加了 `var V` `write_int(E)` `write_char(E)` `E = E` 这四个操作。

