## 公理语义与霍尔三元组
前面我们学习了指称语义中的基础内容，下面我们来学习公理语义中的一部分内容。本节主要介绍霍尔逻辑。

公理语义不关心程序是如何执行的（那是操作语义的事情），也不关心程序对应的数学对象究竟是什么（那是指称语义的事情），而是通过一套逻辑规则（公理和推理规则）来描述程序的行为。

霍尔三元组是公理语义的核心工具。

对于某个程序 $c$，我们可以定义它的霍尔三元组 $\{ P \}c\{ Q \}$，它表示这个程序会满足某种特定的行为规范，其具体含义为：
> 对于任意程序状态 $s_{1}$ 和 $s_{2}$，如果 $s_{1}$ 满足性质 $P$，并且 $(s_{1},s_{2}) \in [\![ c ]\!]$，那么 $s_{2}$ 必须满足性质 $Q$。

其中，$P$ 称为前条件，$Q$ 称为后条件。

或者，更严谨地表述，对于每个程序 $c$，它的霍尔三元组是一个命题，可能成立，也可能不成立。如果能找到适当的前条件 $P$ 和后条件 $Q$，使得对应的 $\{ P \} c \{ Q \}$ 为真，那么我们就找到了程序 $c$ 必须符合的某种行为规范。


## 霍尔三元组的运算规则
霍尔三元组满足一定的运算规则，比较简单的规则主要有如下三条，理解起来都十分容易，我就不多解释了。

### 顺序执行规则
如果 $\{ P \} c_{1} \{ Q \}$ 为真，并且 $\{ Q \} c_{2} \{ R \}$ 为真，那么 $\{ P \}c_{1} ; c_{2} \{ R \}$ 为真。

### 空语句规则
$\{ P \} \text{skip} \{ P \}$ 恒为真。

### 条件分支语句规则
如果 $\{ P \&\& e \} c_{1} \{ Q \}$ 为真，并且 $\{ P \&\& !e \}c_{2} \{ Q \}$ 为真，那么 $\{ P \} \text{ if } (e) \text{ then } \{ c_{1} \} \text{ else } \{ c_{2} \} ~ \{ Q \}$ 为真。

## While 语句规则与循环不变量
 现在，我们单独来讲讲 while 循环的霍尔三元组规则。

为什么要单独讲它？因为，对于顺序执行或者赋值语句之类的操作而言，它们的行为是确定且有限的，在霍尔逻辑中容易证明；但是，对于 while 循环，我们不知道循环会执行多少次，这给我们的证明带来了麻烦。

所以，我们希望能找到一种通用的数学方法，无论循环执行多少次，都能证明它结束之后的状态是正确的。为了做到这一点，我们需要找到一个在循环过程中“始终保持不变”的逻辑性质，这个性质就是**循环不变量**。

什么是循环不变量？它的意思不是说某个变量的值在循环中一直保持不变，而是指**某种关于变量之间关系的“性质”或者“逻辑断言”不变。**

一个合格的循环不变量 $P$ 需要满足下面的三个性质（或者说，需要回答三个问题）：
1. 初始性：它能被“点燃”吗？
	- 在循环开始之前，程序的初始状态（前条件）必须能推出 $P$。
2. 保持性：它能被“传递”下去吗？
	- 这是最核心的规则：$\{ P \land e \} c \{ P \}$。
	- 如果我们在满足 $P$ 且循环条件 $e$ 为真的情况下进入循环体 $c$，那么，当这一轮循环结束时，$P$ 必须依然成立。
3. 终止性：它能“通向成功”吗？
	- 当循环因为条件 $e$ 变为假而退出时，$P \land \neg e$ 必须足够强，足以推出我们想要的后条件 $Q$。

寻找不变量是一件很难的事情：
- 一方面，循环不变量不能太强，否则前条件可能无法推出它；
- 另一方面，循环不变量也不能太弱，否则在循环退出之后，它可能无法推导出后条件。

下面是三道利用循环不变量证明霍尔三元组的例题：
```c
{ x == m }
while (! (x < n)) do {
	x = x - n
}
{ exists y'. n * y' + x = m && 0 <= x < n}
```

```c
{ x == m && y == n}
while (! (! (x < 0) && ! (0 < x)) do {
	y = y - 1;
	x = x - 1
}
{ y == n - m}
```

```c
{ x == m && i == res == 0}
while (i < x) do {
	res = res + x;
	i = i + 1
}
{res == m * m}
```


## 变量赋值语句规则（正向）与最强后条件
在霍尔逻辑中，推理方向通常有两种：正向和逆向

正向推理：
- 正向指的是逻辑推理的方向与程序的实际执行方向一致。
- 在正向推理中，我们已知程序执行前的状态性质 $P$（前条件），通过赋值规则直接推导出执行后的状态性质 $Q$（后条件）。
- 这种正向推导常用于“符号执行”，即从程序的入口开始，沿着代码顺序向后计算每一轮赋值后的最新状态断言。
- 与之相对，传统的霍尔逻辑赋值规则通常是逆向的，它是从我们想要的“目标”（后条件）出发，反推会需要满足的“前提”。

那么，这里的“最强后条件”又是什么意思呢？

对于给定的前条件 $P$ 和程序 $c$，如果 $Q$ 是其最强后条件，那么它必须满足：
> 对于任何使得霍尔三元组 $\{ P \} c \{ Q_{1} \}$ 成立的后条件 $Q_{1}$，$Q$ 都能推出 $Q_{1}$，即 $Q \implies Q_{1}$

“最强”，意味着约束力更强，包含的信息量更大，描述的状态范围更精准。所以说，最强后条件包含了程序执行后，我们所能知道的全部信息，没有任何的冗余，也没有任何的遗漏。

如何构造正向赋值规则的最强后条件？为了不丢失信息，正向赋值规则使用了存在量词来记录变量被覆盖前的旧值（这个旧值，通常被记作 $x_{1}$ 或者 $x'$）：
$$
\{  P \} ~ x = e ~ \{ \exists x_{1}. x= e[x \mapsto x_{1}] \land P[x \mapsto x_{1}] \}
$$

这里，$e[x \mapsto x_{1}]$ 表示将 $e$ 这个表达式中全部 $x$ 更换为 $x_{1}$ 之后，得到的求值结果。后面的 $P[x \mapsto x_{1}]$ 含义类似。

两个例子：
```c
{ x == m && y == n}
x = x + y
{ exists x'. x' + y == x && x' == m && y == n}
```

```c
{ x == m && y == n}
temp = x
{ exists temp'. x == temp && x == m && y == n}
```

## 符号执行（正向）与验证条件生成
符号执行是一种程序分析技术，在本节中，它特指正向地沿着程序的执行路径，将变量视为符号，并根据赋值语句的规则（通常是最强后条件规则）计算每一行代码的执行后，程序状态所满足的数学逻辑断言。

而验证条件生成，是指在符号执行的过程中，产生出一系列需要被证明的逻辑公式（即验证条件）的过程。如果这些生成的验证条件在数学上全部成立，那么根据霍尔逻辑的推理规则，整个程序就符合其给出的规范，也就是对应的霍尔三元组成立。

符号执行中，不同的符号承载了不同的功能：
- `require` 表示“前条件”，即程序执行前必须满足的性质，对应霍尔三元组中的 $P$。
- `ensure` 表示“后条件”，即程序正常终止后必须满足的性质，对应霍尔三元组中的 $Q$。
- `generated` 表示“生成的断言”，即通过符号执行规则自动推导的当前状态性质。
	- 这里，`generated` 的内容，通常就是结合赋值规则，得出最强后条件。
- `inv` 表示“循环不变量”，这是由程序员手动给出的、在循环开始前、循环过程中以及循环退出后都必须保持成立的性质。
- `target` 表示“目标性质”，即当前证明必须达到的逻辑目标。例如，在循环体结束时，生成的断言必须能推导出不变量 `inv`，以保持循环的持续性。

而在生成验证条件的例子中，`|--` 表示“逻辑蕴含关系”，也就是逻辑上前者能推导出后者的意思。

下面是一个符号执行的示例：
```c
// @ require true
// @ ensure x == 10
x = 0;
// @ [generated] 0 == x && true
// @ inv x <= 10
while (x < 10) do 
{
	// @ [generated] x <= 10 && x < 10
	x = x + 1
	// @ [generated] x' + 1 == x && x' <= 10 && x' < 10
	// @ [target] x <= 10
}
// @ [generated] x <= 10 && !(x < 10)
```

而生成的验证条件，就是说 `generated` 的内容，能够推出我们想要的结论，通常需要推出三个：
- 循环开始前，`inv` 是否成立？
- 每一轮循环结束后，`inv` 是否成立？
- 循环退出后，`ensure`（后条件） 是否成立？

分别对应下面三个验证条件：
```c
0 == x && true |-- x <= 10 
```

```c
x' + 1 == x && x' <= 10 && x' < 10 |-- x <= 10
```

```c
x <= 10 && !(x < 10) |-- x == 10
```



