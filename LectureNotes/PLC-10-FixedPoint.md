## 为什么需要不动点和最小不动点？
程序语句的指称语义是一个状态二元关系的集合，表示输入一个状态之后，输出的状态可能是什么。它回答了下面的问题：
> 如果从状态 s 开始执行，最后可能停在哪里？

不动点也是一个程序语句的指称语义，它也是二元关系的集合。

我们需要定义一个 while 循环语句，但是这个东西无法直接定义，需要用其他简单元素的组合来定义。

怎么定义？我们需要不断更新自己的当前集合。

怎么更新？比如说，我们有个指称语义 X（可以简单理解为二元关系的集合，或者一种执行状态，或者干脆就理解成一个函数，给 X 一个输入，它会给你一个输出），然后有一个泛函 F（所谓泛函，就是输入一个函数，输出另一个函数），我们希望
$$
F(X) = X
$$

这样的 X 就是不动点。

为什么希望找不动点？因为 F (X) 相当于把 X 的执行逻辑展开，得到一个新的二元关系集合（在循环中理解，F 就是告诉你循环的整体流程，而 X 类似于循环体内部的结构）。如果它和之前的 X 完全相同，那么说明我们找到的 X 是完备的，包含了可能的所有情况，不需要继续“更新”

为什么要找最小不动点？
- 如果我们找的是普通的不动点，它可能存在一些奇怪的输入输出关系：比如说，明明我是死循环，不应该输出结果，但是它却能输出结果，因为它不是最小不动点。
- 而最小不动点对于导致死循环的输入，一定不会有输出结果；对于能使程序正常结束的输入，它会给出正常的输出结果。
- 这也解释了它为什么是最小的：因为它不包含任何多余的部分。

最小不动点：
- 任何导致循环陷入无限循环的输入，在最小不动点中都不会给出输出。
- 任何使得循环正常结束的输入，在最小不动点中都会给出输出。

## 循环语句的不动点分析
函数 $F(X) \triangleq \text{test\_true}([\![ e ]\!] \circ [\![ c ]\!]) \circ X \cup \text{test\_false} ([\![ e ]\!])$ 的不动点具有下面这些性质：

### 性质 1：正常终止情况
如果从 $s_{1}$ 出发，执行循环语句 $\text{while } (e) \text{ do } \{ c \}$ 会以 $s_{2}$ 为终止状态结束运行，那么对于任意一个 $F$ 的不动点 $X$，都有：
- $(s_{1}, s_{2}) \in X$
- 不存在其他的 $s$ 使得 $(s_{1}, s) \in X$

解读：如果从某个初始状态开始，执行循环语句之后能正常结束，那么不动点中有且仅有一个结束状态，与这个初始状态对应。

### 性质 2：循环体内部陷入死循环
如果从 $s_{1}$ 出发，执行循环语句 $\text{while } (e) \text{ do } \{ c \}$ 会在某一次执行循环体的过程中**在循环体内部陷入死循环**，那么对于任何一个 $F$ 的不动点 $X$，都有
- 不存在 $s$ 使得 $(s_{1}, s) \in X$

解读：如果某个初始状态使得循环体内部的语句 $c$ 陷入死循环，那么这个初始状态在不动点中是不存在对应的结束状态的。

### 性质 3：循环体自身循环不终止（重点）
如果从 $s_{1}$ 出发，执行循环语句 $\text{while } (e) \text{ do } \{ c \}$ 时，每一次执行循环体后依次经过程序状态 $s_{2},s_{3}, \dots$ 循环不终止，那么对于任意一个 $F$ 的不动点 $X$，以及任意程序状态 $s$，都有：
- 要么 $(s_{1}, s), (s_{2}, s), (s_{3}, s),\dots$ 全部都是 $X$ 的元素
- 要么 $(s_{1}, s), (s_{2}, s), (s_{3}, s),\dots$ 全部都不是 $X$ 的元素

解读：性质 3 的解读稍微不那么直观。

如果某个初始状态使得循环体自身能够往复运行而不终止，那么由它所得的一系列无穷状态 $s_{1} \to s_{2} \to s_{3} \to \dots$ ，在不动点 $X$ 这个集合里，这些状态序列与任意一个程序状态 $s$ 的关系是被“捆绑”在一起的。

为什么它们的关系是被“捆绑”在一起的？在逻辑上是这样理解的：
- 如果 $(s_{1}, s) \in X$，而根据前面的定义，从 $s_{1}$ 出发，能到达 $s_{2}$，那么必然有 $(s_{2}, s)$，即：如果从 $s_{1}$ 开始能终止于 $s$，那么从 $s_{2}$ 开始也必然也能终止于 $s$。后面的一系列状态也是同理。
- 如果 $(s_{1}, s) \not\in X$，同样地，我们知道从 $s_{1}$ 出发，必然会到达后面无穷多的状态 $s_{2}, s_{3}, s_{4}, \dots$，这个状态序列是无穷的（而 $s$ 显然不在这个序列中），它们都无法到达 $s$。

结论：这是“全有”或“全无”的选择 (**All or Nothing**)
> 这个链条是无穷的。如果你承认 $s_1$ 能到达某个终点 $s$，那么逻辑上你就必须承认 $s_2, s_3 \dots$ 全都能到达同一个 $s$。反之，如果你认为其中任何一个不能到达 $s$，那么整个链条都会在逻辑上坍塌，导致全部都不在 $X$ 中。

为什么会有这种“全有或全无”的情况？这涉及到了**最大不动点**与**最小不动点**的区别。

- **不动点不唯一**：对于一个死循环，满足 $X = F(X)$ 的集合 $X$ 可能有很多个。
    - 你可以选择一个**非常大**的 $X$（最大不动点），把 $(s_1, s), (s_2, s) \dots$ 全部塞进去。在逻辑上这依然成立，因为它满足方程的自洽性，但并不符合程序实际运行的物理真实。
    - 你也可以选择一个**非常小**的 $X$（最小不动点），不包含任何关于 $s_1, s_2 \dots$ 的终点信息——这恰恰是我们需要的！
- **指称语义的选择**：我们定义程序的语义为**最小不动点（Least Fixed Point）**。（其实是因为我们需要最小的不动点，因为我们要排除那些死循环的情况）
    - 既然性质 3 给了我们“全有”或“全无”的选择，为了求“最小”（最严格、最合理），我们当然选择“**全无**”。
    - **这就解释了死循环的语义**：在最小不动点中，由于没有任何一条路径能通过 `test_false`（终止条件）逃离循环，所以对于死循环的起点 $s_1$，不存在任何 $s$ 使得 $(s_1, s) \in X$。

如果某个初始状态 $s_1$ 导致了无限循环，那么：
1. 在**任何**不动点中，你都找不到“部分终止”的情况。它在逻辑上是高度一致的。
2. 在**最小不动点**（即我们真正关心的程序语义）中，这些 $(s_i, s)$ **全部都不是 $X$ 的元素**。
3. 这完美契合了我们对死循环的认知：**死循环没有终止状态**。

### 总结
在之前的 [[PLC-7-DenotationsAsRels]] 中，我们通过两种递归序列（iterLB 和 boundedLB）定义过循环语句的指称语义 $[\![ \text{while } (e) \text{ do } \{ c \} ]\!]$，而在不动点理论中，根据上面的三条性质，我们可以由最小不动点来定义上面的指称语义。

$[\![ \text{while } (e) \text{ do } \{ c \} ]\!]$ 可以被定义为下述函数的最小不动点：
$$
F(X) \triangleq \text{test\_true}([\![ e ]\!] \circ [\![ c ]\!]) \circ X \cup \text{test\_false} ([\![ e ]\!])
$$
----

补充： `boundedLB` 是通过 $0, 1, 2 \dots n$ 步迭代来逼近不动点的,。
- 对于**正常终止**（性质 1），只要 $n$ 足够大，`boundedLBn` 就能抓到那个终止状态 $s_2$。
- 对于**死循环**（性质 3），无论 $n$ 有多大，`boundedLBn` 永远抓不到任何终止状态（因为它永远碰不到 `test_false`）。
- 当 $n \to \infty$ 取并集时，死循环对应的结果集依然是**空集**。这正是最小不动点的结果,。


## 怎么寻找最小不动点？——利用 Kleene 不动点定理
Kleene 不动点定理告诉我们：要找最小不动点，只需要不断迭代，然后找所有一个序列的**上确界**即可。（或者说，就是所有集合的并集）

这和我们一贯的思想相符：不是一次性找完，而是不断逼近的过程。

刚开始，我们只有一个空集，只能找到对应循环 0 次的结果。

然后，我们在空集的基础上迭代。这时候，找循环 1 次的结果时，就会递归回到循环 0 次的结果。这种时候就类似数学归纳法，可以使用之前的结果。

这样，每次我们有“执行次数不多于 n-1 次的循环语义”，然后执行第 n 次循环的时候，利用类似归纳假设的部分，就可以完成 n 次循环的部分。

## 偏序集与完备偏序集

### 偏序集
已知 $A$ 是一个集合，$\leq_{A}$ 是定义在集合 $A$ 上的二元关系。满足下面三个条件的 $(A, \leq_{A})$ 成为一个偏序集 (Partial Ordering):
- 自反性：对于任意 $a \in A$，都有 $a \leq_{A} a$
- 传递性：对于任意 $a, b, c \in A$，如果 $a \leq_{A} b, b \leq_{A} c$，那么 $a \leq_{A} c$
- 反对称性：对于任意 $a, b \in A$，如果 $a \leq_{A} b, b \leq_{A} a$，那么 $a = b$

其中的二元关系 $\leq_{A}$ 被称为“偏序关系”。

> 在程序语义中，我们通常用自己关系 $\subseteq$ 作为偏序关系 $\leq_{A}$。如果 $a \leq_{A} b$，意思不是 $a$ 的数值比 $b$ 小，而是 $b$ 描述的程序行为比 $a$ 更丰富、更确定，或者说，$b$ 给出的**信息更多**。

### 完备偏序集
如果偏序集 $(A, \leq_{A})$ 还满足下面的性质，那么它是一个完备偏序集 (Complete Partial Ordering)：
- 完备性：对于任意 $S \subseteq A$，如果 $S$ 中任意两个元素都可以大小比较（*注：这里的大小比较，指的是使用我们定义的二元关系 $\leq_{A}$ 来比较，而不是使用一般的大于号和小于号来比较*），那么 $S$ 有上确界 (Least Upper Bound, lub)，记作 $\text{lub}(S)$，即：
	- 对于任意 $a \in S$，都有 $a \leq_{A} \text{lub}(S)$
	- 如果某个 $b \in A$，使得每一个 $a \in S$，都有 $a \leq_{A} b$（我们把这个 $b$ 叫做 $S$ 的“上界”），那么 $\text{lub}(S) \leq_A b$

简单来说，上确界就是所有上界中最“小”的那个。*注：同样，这里的“小”不是通常的大小比较，而是根据我们定义的二元关系 $\leq_{A}$ 来确定的。即 ：$a 不大于 b \iff a \leq_{A} b$。*

链的定义：
> 符合“$S$ 中任意两个元素都可以大小比较”的子集 $S$，被称为偏序集 $A$ 上的一条链。

完备偏序集的含义就是：
> 如果一个偏序集中的任何一条链都有上确界，那么这个偏序集就是完备偏序集。

> [!NOTE]
> 注意：空集也是一条链，在考虑偏序集的链时，不要忽略空集！

### 单调函数
如果 $(A, \leq_{A})$ 是一个偏序集，那么 $F: A \to A$ 是一个单调函数，当且仅当：对于任意 $a, b \in A$，如果 $a \leq_{A} b$，那么 $F(a) \leq_{A} F(b)$。

> 单调函数保证了“输入的信息越多，输出的信息也越多”。

### 单调连续函数
如果 $(A, \leq_{A})$ 是一个完备偏序集，那么单调函数 $F: A \to A$ 是连续的，当且仅当：对于任意一条非空链 $S$，$F(\text{lub}(S)) = \text{lub}(F(S))$。

> 这是一个更强的要求，它意味着：“先取极限再跑一步”的效果，等于“先跑很多步再取极限”。

### 引理：链在被单调函数映射之后还是一条链
如果 $S$ 是偏序集 $(A, \leq_{A})$ 上的一条链，$F: A \to A$ 是一个单调函数，那么 $F(S) \triangleq \{ F(a) \mid a \in S \}$ 也是一条链。

证明：这个引理由链的定义即可证明。

简单来说，如果 $a, b \in S$ 并且 $a \leq b$，那么 $F(a), F(b) \in F(S)$ 且 $F(a) \leq F(b)$，说明 $F(S)$ 中的任意两个元素都可以相互比较。

### 引理：完备偏序集有最小元
如果 $(A, \leq_{A})$ 是一个完备偏序集，那么这个集合上有最小元，记作 $\bot$。这个最小元的值就是 $\text{lub}(\emptyset)$

> 在程序语义中，由于偏序关系通常是集合的包含关系 $\subseteq$，所以最小元通常是空集 $\emptyset$。它代表“完全没有任何信息”或者“程序还没有开始运行”。

证明：空集 $\emptyset$ 是 $(A, \leq_{A})$ 上的一条链，而 $A$ 中任何一个元素，都是空集的上界（*这是由于上界的定义可以由“空真”达成：空集中没有元素，所以不用比较，所以任何元素都是空集的上界*）。因此，对于任意 $a \in A$ ，都有 $\text{lub}(\emptyset) \leq_{A} a$，即 $\text{lub}(\emptyset)$ 就是该完备偏序集的最小元，记作 $\bot$。

### 引理：对最小元利用单调连续函数反复迭代得到一条链
如果 $F$ 是完备偏序集 $(A, \leq_{A})$ 上的单调连续函数，那么 $\{ \bot, F(\bot), F(F(\bot)),\dots \}$ 是 $(A, \leq_{A})$ 上的一条链。

> 由于 $F$ 是单调的，从“空（$\bot$）”开始反复使用 $F$，我们会得到一个信息量不断增加的序列：$\{ \bot, F(\bot), F(F(\bot)),\dots \}$。这对应我们之前学习过的 $\text{boundedLB}_{n}$ 的每一步迭代。

证明：
由于 $\bot$ 是最小元，所以 $\bot \leq F(\bot)$，而由于 $F$ 是单调函数，所以 $F(\bot) \leq F(F(\bot))$，以此类推，即可说明 $\{ \bot, F(\bot), F(F(\bot)),\dots \}$ 中的全部元素都是可以相互比较的，因此是一条链。

### 定理：完备偏序集上单调连续函数的不动点构造（Kleene 不动点构造定理）
如果 $F$ 是完备偏序集 $(A, \leq_{A})$ 上的单调连续函数，那么 $\text{lub}(\{ \bot, F(\bot), F(F(\bot)),\dots \})$ 是 $F$ 的一个不动点。

> 只要你顺着这个迭代链一直走下去，最终的那个“极限（上确界）”就是我们要找的程序语义。

证明：
令 $S = \{ \bot, F(\bot), F(F(\bot)), \dots \}$ 为迭代序列构成的集合。我们的目标是证明 $X = \text{lub}(S)$ 满足 $F(X) = X$。

1. **构造迭代链**： 由于 $\bot$ 是完备偏序集的最小元，根据定义有 $\bot \leq_A F(\bot)$。又因为 $F$ 是单调函数，我们可以对上述不等式两边重复作用 $F$，得到： $\bot \leq_A F(\bot) \leq_A F(F(\bot)) \leq_A F(F(F(\bot))) \leq_A \dots$ 因此，$S = \{ \bot, F(\bot), F^2(\bot), \dots \}$ 构成 $(A, \leq_A)$ 上的一条**链**。
    
2. **利用连续性展开 $F(X)$**： 设 $X = \text{lub}(S)$。我们要计算 $F(X)$，即： $F(X) = F(\text{lub}(\{ \bot, F(\bot), F^2(\bot), \dots \}))$ 由于 $F$ 是**单调连续函数**，根据连续性的定义（$F(\text{lub}(S)) = \text{lub}(F(S))$），我们可以将 $F$ 移入上确界符号内部： $F(X) = \text{lub}(\{ F(\bot), F(F(\bot)), F(F(F(\bot))), \dots \})$
    
3. **比较两个集合的上确界**： 现在我们比较两个集合：
    - 原始集合 $S = \{ \bot, F(\bot), F^2(\bot), \dots \}$
    - 映射后的集合 $F(S) = \{ F(\bot), F^2(\bot), F^3(\bot), \dots \}$ 可以看到，$S$ 只是比 $F(S)$ 多了一个元素 $\bot$。
      
4. **得出结论**： 由于 $\bot$ 是集合 $A$ 中的最小元，对于 $F(S)$ 中的任何元素 $a$，都有 $\bot \leq_A a$。在偏序集中，**为一个非空集合添加一个小于其所有元素的元素，不会改变该集合的上确界**。因此： $\text{lub}(\{ \bot, F(\bot), F^2(\bot), \dots \}) = \text{lub}(\{ F(\bot), F^2(\bot), \dots \})$ 即： $X = F(X)$。
    

### 定理：通过迭代链构造出的不动点是最小不动点
如果 $F$ 是完备偏序集 $(A, \leq_{A})$ 上的单调连续函数且 $F(a) = a$，那么 $\text{lub}(\{ \bot, F(\bot), F(F(\bot)),\dots \}) \leq_{A} a$。

> 我们顺着迭代链构造出的不动点，它不会超过任何的不动点，因此它是最小不动点。

证明：
首先，根据最小元的定义， $\bot \leq_{A} a$。

两边都扔进函数 $F$，则有：
$$
F(\bot) \leq_{A} F(a) = a
$$

继续把两边都扔进 $F$，则有：
$$
F(F(\bot)) \leq_{A} F(a) = a
$$

以此类推，可得 $\{ \bot, F(\bot), F(F(\bot)),\dots \}$ 中的所有元素在偏序关系的视角下都不超过 $a$，所以这个链的上确界也不超过 $a$，即：
$$
\text{lub}(\{ \bot, F(\bot), F(F(\bot)),\dots \}) \leq_{A} a
$$

## 用 Kleene 不动点定义 while 语句语义
根据上面的定理，构造不动点，需要一个完备偏序集和一个单调连续函数：
- $(\mathcal{P}(\text{state} \times \text{state}), \subseteq)$ 是一个完备偏序集。
- $F(X) \triangleq \text{test\_true}([\![ e ]\!] \circ [\![ c ]\!]) \circ X \cup \text{test\_false} ([\![ e ]\!])$ 是一个单调连续函数。如何证明？根据下面三个性质：
	- $G(X) = Y \circ X$ 是单调连续函数
	- $H(X) = X \cup Y$ 是单调连续函数
	- 如果 $G(X)$ 与 $H(X)$ 都是单调连续函数，那么 $G(H(X))$ 也是单调连续函数。


那么，根据定理，$F$ 的最小不动点是：
$$
\bigcup_{n \in \mathbb{N}} (F^{(n)}(\emptyset))
$$
这和我们之前的定义怎么结合？如下：
$$
F^{(n)}(\emptyset) = \text{boundedLB}_{n}([\![ e ]\!], [\![ c ]\!])
$$

为什么我们需要学习不动点理论？注意到，我们在 [[PLC-7-DenotationsAsRels]] 中给出过一个自指的 while 循环语句的指称语义定义：
$$
[\![ \text{while } (e) \text{ do } \{ c \} ]\!] = \text{test\_false} ( [\![ e ]\!]) \cup \text{test\_true}([\![ e ]\!]) \circ [\![ c ]\!] \circ [\![ \text{while } (e) \text{ do } \{ c \} ]\!]
$$

当时，我们认为这个定义不合规，或者说，我们不会求解上面这个方程，但现在经过不动点理论的学习，我们知道：
> 只要把语义空间看作完备偏序集（CPO），把循环展开看作是**单调连续函数**，那么从空集开始**不断展开并取上确界**，就能得到这个方程的解。


**比喻理解：** 想象你在**盖一座无限高的塔**（ While 循环的完整行为）。
- **偏序集**是地基，规定了砖头必须一层层往上落（$\leq$ 表示高度）。
- **最小元 $\bot$** 是地面的第一块砖（空集）。
- **单调连续函数 $F$** 是一台自动盖楼机：你给它 $n$ 层楼，它能稳稳地盖出第 $n+1$ 层，且不会拆掉旧楼。
- **完备性**保证了即使工程是无限的，这座塔在数学上也存在一个确定的“最终高度”。
- **不动点定理**告诉你：虽然你没法数完无限层砖，但你可以通过观察这台盖楼机的设计图，直接锁定这座塔最终会停留在哪个高度。